
# Jitte emulator

## Introduction

Jitte is a software framework which emulates
execution of Tanto applications on the conventional CPUs. 
It supports emulation for the host API as well as kernel execution.

The main purpose of Jitte is boosting the development productivity by providing 
a convenient toolchain  for debugging and testing Tanto applications on 
the conventional CPUs, without using the real Tenstorrent AI hardware.

Furthermore, the software engineers interested in general purpose programming
of Tenstorrent AI accelerators can use Jitte for evaluation of the respective
software development stack prior to purchasing the actual hardware.


## Origin of the name

According to [Wikipedia](https://en.wikipedia.org/wiki/Jitte),
a jitte ("ten hands") is a blunt melee weapon that was used in Edo-period Japan.
The weapon name implies that it confers power of ten hands on its wielder.

Likewise, the Tanto emulator magnifies productivity of the programmer
by providing an opportunity to conveniently prototype and debug Tanto applications 
before deploying them on the AI accelerators. Actually, all the kernels in this package were
initially developed using the Jitte emulator. This approach has dramatically reduced 
the cost of kernel debugging on the target hardware.


## Operation principles

The Jitte framework includes the following principal components:

* Emulator for a subset of TT-Metalium host API and runtime
* Toolchain for just-in-time (JIT) compilation of TT-Metalium kernels
* Device model which emulates:
    * essential hardware components of an accelerator chip
    * interaction between host and device
    * parallel execution of kernels
* Emulation library for TT-Metal compute and dataflow primitives
* RISC-V instruction set simulator which runs kernels on the conventional CPUs.

The Jitte device model simulates the inherent hardware parallelism, 
so that each kernel instance runs in its own parallel light-weight thread. 
Modeling of the entire chip may require running hundreds of parallel threads. 
This aspect makes using the standard OS threads impractical. 
Instead, the implementation uses a light-weight model of parallelism 
(asymmetric coroutines).

The Jitte framework includes a collection of object libraries and C++ header files.
For running a TT-Metalium application using Jitte, it must be recompiled 
using the Jitte header files instead of the actual TT-Metalium host API headers
and linked with the Jitte object libraries.

Since all access to the TT-Metalium host API is encapsulated within the Tanto
host API library, this library must be also recompiled using the Jitte header
files. The resulting object library must be used for linking the emulated applications
instead of its standard version built for TT-Metalium.

Note that Jitte is not designed for emulation of arbitrary TT-Metalium applications.
It only supports execution of applications which use Tanto host API
and device kernels generated by the Tanto compiler frontend.

Only the single-chip Wormhole B0 architecture is currently supported.


## Code structure

The Jitte source code is contained in the subdirectory `src`.
It is structured into these modules:

```
device                   device model
    api                  top level device side API
    arch                 architecture descriptors
    core                 core functionality
    dispatch             dispatch functionality
    ref                  reference implementation
    riscv                interfaces specific to RISC-V
    schedule             scheduler managing concurrency and synchronization
    vendor               third party software

tt_metal                 emulator for TT-Metalium host API and runtime

whisper                  functionality related to RISC-V ISA simulator
    interp               RISC-V ISA simulator
    linker               lightweight linker for kernels
    riscv                top level API 
```


## Jitte home directory

Directory `home` contains Jitte replacement of essential resources
from the regular TT-Metalium home directory. The path to the Jitte
home directory must be assigned to the `TT_METAL_HOME` environment
variable before running the Jitte applications.


## Environment variables

Before running Jitte applications, two environment variable must be set:

```
export TT_METAL_HOME=<jitte_home>
export TT_ARCH=wormhole_b0
```

where `<jitte_home>` is the path to the Jitte home directory.


## Prerequisites

Jitte requires the same version of Clang / LLVM infrastructure which is used for
building the Tanto core SDK. Make sure that the CLANG C++ compiler `clang++`
is installed and directly callable from the command line (this might require updating 
the `PATH` variable):

```
clang++ --version
```


## Building from source

The shell scripts for building the emulator libraries and examples are contained
in the subdirectory `prj`. They will place the built libraries and example applications
into subdirectories `lib` and `bin` respectively.

To build all libraries and applications, set `prj` as your current directory and
run this command:

```
./build_all.sh
```


## Running examples

The programming examples will be built in the subdirectory `bin/examples`.
They include these Jitte applications:

```
eltwise_binary
eltwise_sfpu
matmul_multi_core
matmul_single_core
```

Before running examples, set the environment variables as described above
in the "Environment variables" section.

Make sure that `clang++` is directly callable from the command line as described above
in the "Prerequisites" section.

Assuming `jitte` as the current directory, run individual examples, for instance:

```
./bin/examples/eltwise_binary
```


## Building Tanto software modules for emulation

Building Tanto applications using Jitte requires the specialised version of
Tanto host runtime library. The script for building this library is located
in the subdirectory `tanto/jitte/prj/host` in the `tanto` section.
Set this directory as current and run the script using these commands:

```
cd tanto/jitte/prj/host
./build_core.sh
```

To build Jitte applications for other Tanto components including `algo`,
`yari/op` and `yari/nn`, use the build scripts located in the `jitte/prj`
subdirectories of the respective sections. Assuming the repository root
directory as the starting current directory, perform build using 
the following commands.

For the `algo` module:

```
cd algo/jitte/prj/basic
./build_all.sh
```

For the `yari/op` module:

```
cd yari/op/jitte/prj
./build_all.sh
```

For the `yari/nn` module:

```
cd yari/nn/jitte/prj
./build_all.sh
```

The object libraries and binary executables will be placed in the subdirectories
`jitte/lib` and `jitte/bin` respectively.

The modules which include device kernels require deployment of these kernels
in the Jitte home directory before running applications. This deployment
is performed using the `deploy_jitte.sh` scripts located in the respective
`jitte/prj` subdirectories. 

Assuming the repository root directory as the starting current directory, 
deploy kernels using the following commands.

For the `algo` module:

```
cd algo/jitte/prj
./deploy_jitte.sh
```

For the `yari/op` module:

```
cd yari/op/jitte/prj
./deploy_jitte.sh
```

The similar common pattern can be adopted for building the user applications.

